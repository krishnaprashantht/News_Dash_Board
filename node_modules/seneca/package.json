{
  "name": "seneca",
  "description": "A toolkit for building Minimum Viable Products",
  "keywords": [
    "minimum",
    "viable",
    "product",
    "toolkit",
    "startup",
    "lean"
  ],
  "version": "0.5.8",
  "license": "MIT",
  "homepage": "http://senecajs.org",
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com/"
  },
  "contributors": [
    {
      "name": "Richard Rodger",
      "email": "richard@ricebridge.com",
      "url": "http://richardrodger.com/"
    },
    {
      "name": "Tane Piper",
      "email": "piper.tane@gmail.com",
      "url": "http://tanepiper.com"
    },
    {
      "name": "Marian Radulescu",
      "email": "marian.radulescu@gmail.com"
    },
    {
      "name": "Alexandru Mircea",
      "email": "mircea.alexandru@gmail.com"
    },
    {
      "name": "Cristian Ianto",
      "email": "cristian.ianto@nearform.com"
    }
  ],
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "underscore": "~1.4.2",
    "gex": "~0.1.1",
    "parambulator": "~0.1.1",
    "async": "~0.1.22",
    "node-uuid": "~1.3.3",
    "connect": "~2.4.2",
    "oauth": "~0.9.8",
    "cookies": "~0.3.0",
    "http-proxy": "~0.8.3",
    "request": "~2.11.4",
    "sockjs": "~0.3.5",
    "optimist": "~0.3.5",
    "eyes": "~0.1.8",
    "chai": "~1.4.2",
    "nid": "~0.3.0",
    "pegjs": "~0.7.0"
  },
  "main": "lib/seneca",
  "files": [
    "LICENSE.txt",
    "README.md",
    "CHANGES.md",
    "lib",
    "plugin",
    "test/store/shared.js"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/rjrodger/seneca.git"
  },
  "readme": "# seneca - Node.js module\n\n## A Node.js toolkit for startups building Minimum Viable Products\n\nThis is a community project of the http://nodejsdublin.com meetup.\n\nSeneca is a toolkit for organizing the business logic of your app. You\ncan break down your app into \"stuff that happens\", rather than\nfocusing on data models or managing dependencies.\n\nFor a gentle introduction to this module, see the [senecajs.org](http://senecajs.org) site.\n\n\nIf you're using this module, feel free to contact us on twitter if you have any questions! :) [@nodejsdublin](http://twitter.com/nodejsdublin)\n\nCurrent Version: 0.5.8\n\nTested on: node 0.10.6\n\n\nUse this module to define commands that work by taking in some JSON, and returning some JSON. The command to run is selected by pattern-matching on the the input JSON.\nThere are built-in and optional sets of commands that help you build Minimum Viable Products: data storage, user management, distributed logic, caching, logging, etc.\nAnd you can define your own product by breaking it into a set of commands - \"stuff that happens\".\n\nThat's pretty much it.\n\n\n_Why do this?_\n\nIt doesn't matter,\n\n   * who provides the functionality,\n   * where it lives (on the network),\n   * what it depends on,\n   * it's easy to define blocks of functionality (plugins!).\n\nSo long as _some_ command can handle a given JSON document, you're good.\n\nHere's an example:\n\n```javascript\nvar seneca = require('seneca')()\n\nseneca.add( {cmd:'sales-tax'}, function(args,callback){\n  var rate  = 0.23\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\nseneca.act( {cmd:'salestax', net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nIn this code, whenever seneca sees the pattern\n<code>{cmd:'sales-tax'}</code>, it executes the function associated\nwith this pattern, which calculates sales tax. Yah!\n\nThe _seneca.add_ method adds a new pattern, and the function to execute whenever that pattern occurs.\n\nThe _seneca.act_ method accepts an object, and runs the command, if any, that matches.\n\nWhere does the sales tax rate come from? Let's try it again:\n\n```javascript\nseneca.add( {cmd:'config'}, function(args,callback){\n  var config = {\n    rate: 0.23\n  }\n  var value = config[args.prop]\n  callback(null,{value:value})\n})\n\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  seneca.act( {cmd:'config', prop:'rate'}, function(err,result){\n    var rate  = parseFloat(result.value)\n    var total = args.net * (1+rate)\n    callback(null,{total:total})\n  })\n})\n\nseneca.act( {cmd:'salestax', net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nThe _config_ command provides you with your configuration. This is\ncool because it doesn't matter _where_ it gets the configuration from - hard-coded, file system, database, network service, whatever. Did\nyou have to define an abstraction API to make this work? Nope.\n\nThere's a little but too much verbosity here, don't you think? Let's fix that:\n\n\n```javascript\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nBy _pinning_ a pattern, you get a little API of matching function calls.\nThe _shop_ object gets a set of methods that match the pattern: _shop.salestax_ and _shop.config_.\n\n\n_Programmer Anarchy_\n\nThe way to build Node.js systems, is to build lots of little\nprocesses. Here's a great talk explaining why you should do this:\n[Programmer Anarchy](http://vimeo.com/43690647).\n\nSeneca makes this really easy. Let's put configuration out on the network into it's own process:\n\n```javascript\nseneca.add( {cmd:'config'}, function(args,callback){\n  var config = {\n    rate: 0.23\n  }\n  var value = config[args.prop]\n  callback(null,{value:value})\n})\n\n\nseneca.use('transport')\n\nvar connect = require('connect')\nvar app = connect()\n  .use( connect.json() )\n  .use( seneca.service() )\n  .listen(10171)\n```\n\nThe _transport_ plugin exposes any commands over a HTTP end point. You\ncan then use the _connect_ module, for example, to run a little web\nserver. The _seneca.service_ method returns a _connect_ middleware\nfunction to do this.\n\nYour implementation of the configuration code _stays the same_.\n\nThe client code looks like this:\n\n\n```javascript\nseneca.use('transport',{\n  pins:[ {cmd:'config'} ]\n})\n\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  seneca.act( {cmd:'config', prop:'rate'}, function(err,result){\n    var rate  = parseFloat(result.value)\n    var total = args.net * (1+rate)\n    callback(null,{total:total})\n  })\n})\n\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nOn the client-side, the _transport_ plugin takes a _pins_\nparameter. You can use this to specify which patterns are remote.\n\nAgain, notice that your sales tax code _does not change_. It does not\nneed to know where the configuration comes from, who provides it, or\nhow.\n\nYou can do this with every command.\n\n\n_Keeping the Business Happy_\n\nThe thing about business requirements is that have no respect for\ncommand sense, logic or orderly structure. The real world is\nmessy. \n\nIn our example, let's say some countries have single sales tax rate,\nand others have a variable rate, which depends either on locality, or product category.\n\nHere's the code. We'll rip out the configuration code for this example.\n\n```javascript\n// fixed rate\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  var rate  = 0.23\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\n// local rates\nseneca.add( {cmd:'salestax',country:'US'}, function(args,callback){\n  var state = {\n    'NY': 0.04,\n    'CA': 0.0625\n    // ...\n  }\n  var rate = state[args.state]\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\n// categories\nseneca.add( {cmd:'salestax',country:'IE'}, function(args,callback){\n  var category = {\n    'top': 0.23,\n    'reduced': 0.135\n    // ...\n  }\n  var rate = category[args.category]\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100,country:'DE'}, function(err,result){\n  console.log( 'DE: '+result.total )\n})\n\nshop.salestax({net:100,country:'US',state:'NY'}, function(err,result){\n  console.log( 'US,NY: '+result.total )\n})\n\nshop.salestax({net:100,country:'IE',category:'reduced'}, function(err,result){\n  console.log( 'IE: '+result.total )\n})\n\n```\n\nIn this case, you provide different implementations for different\npatterns. This lets you isolate complexity into well-defined\nplaces. It also means you can deal with special cases very easily.\n\n\n# Stay tuned...\n\nMore to come...\n\n\n\n### Acknowledgements\n\nThis module depends on many, many Node.js modules - thank you!\n\nDevelopment is sponsored by [nearForm](http://nearform.com)\n\n<img src=\"http://www.nearform.com/img/sponsored-by-nearform.png\" width=\"300\">\n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/seneca/issues"
  },
  "_id": "seneca@0.5.8",
  "_from": "seneca@"
}
