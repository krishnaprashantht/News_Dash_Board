<h1>parambulator - Node.js module</h1>

<p>A simple way to generate nice error messages for named parameters.</p>

<p>If you're using this module, feel free to contact me on twitter if you have any questions! :) <a href="http://twitter.com/rjrodger">@rjrodger</a></p>

<p>Current Version: 0.0.1</p>

<p>Tested on: node 0.6.15, 0.8.6, 0.9.0</p>

<p>Use this module to validate input or configuration parameters provided as JSON. You can ensure that the JSON structure and data types are what you need. You'll get friendly, useful error messages for your users, and that makes your API better!</p>

<div class="highlight"><pre lang="javascript">var parambulator = require('parambulator')

var paramcheck = parambulator({ 
  price: {type$:'number'}
})

// this passes
paramcheck.validate( { price: 10.99 }, function(err) { console.log(err) } )

// this fails - price should be a number
paramcheck.validate( { price: 'free!' }, function(err) { console.log(err) } )
// output: The value 'free!' is not of type 'number' (parent: price). 
</pre></div>

<p><em>Why?</em></p>

<p>You're writing a module and you accept configuration as a structured JavaScript object. For example, opening a database connection: <a href="http://mongodb.github.com/node-mongodb-native/api-generated/server.html">MongoDB driver</a>. Or you want to have named parameters: <a href="http://nodejs.org/api/http.html#http_http_request_options_callback">http.request</a>.</p>

<p>It's nice to be able to validate the input and provide useful error messages, without hand-coding the validation.</p>

<p><em>But What About JSONSchema!</em></p>

<p>Yes, <a href="http://json-schema.org">JSONSchema</a> would be the proper way to do this. But the syntax is too hard, and the error messages aren't friendly. This is a <a href="http://www.jwz.org/doc/worse-is-better.html">Worse is Better!</a> approach.</p>

<p>There's also a philosophical difference. JSONSchema defines a formal structure, so you need to be fairly precise and complete. Parambulator defines a list of rules that are tested in the order you specify, and you can be vague and incomplete.</p>

<p>Key Features:</p>

<ul>
<li>Easy syntax, rules are tested in order</li>
<li>Add your own rules</li>
<li>Customize the error messages</li>
</ul>

<p>This is still an early version so there's probably some wierdness - let me know.</p>

<p>And yes Virginia, it does <a href="http://en.wikipedia.org/wiki/Self-hosting">validate its own input</a>.</p>

<h2>Installation</h2>

<pre><code>npm install parambulator
</code></pre>

<p>And in your code:</p>

<pre><code>var parambulator = require('parambulator')
</code></pre>

<h2>Usage</h2>

<p>Import the module using the standard <em>require</em> syntax:</p>

<div class="highlight"><pre lang="javascript">var parambulator = require('parambulator')
</pre></div>

<p>This is a function that creates <em>Parambulator</em> object instances. This function accepts two arguments:</p>

<ul>
<li><em>spec</em> - the rule specification to test against</li>
<li><em>pref</em> - your preferences, such as custom error messages and rules</li>
</ul>

<p>Example:</p>

<div class="highlight"><pre lang="javascript">var paramcheck = parambulator({ price: {type$:'number'} })
</pre></div>

<p>The <em>paramcheck</em> variable is an instance of <em>Parambulator</em>. This object only has one method: <em>validate</em>, which accepts two arguments:</p>

<ul>
<li><em>args</em>: the object to validate</li>
<li><em>cb</em>: a callback function, following the standard Node.js error convention (first arg is an Error)</li>
</ul>

<p>Example:</p>

<div class="highlight"><pre lang="javascript">paramcheck.validate( { price: 10.99 }, function(err) { console.log(err) } )
</pre></div>

<p>The callback function is called when the validation has completed. Processing of rules stops as soon as a rule fails. If validation fails, the first argument to the callback will be a standard JavaScript <em>Error</em> object, with an error message in the <em>message</em> property.</p>

<h3>Examples</h3>

<p>Heavily commented examples are provided in the <em>doc/examples</em> folder: <a href='https://github.com/rjrodger/parambulator/tree/master/doc/examples'>https://github.com/rjrodger/parambulator/tree/master/doc/examples</a></p>

<p>You should probably read this rest of this first, though. </p>

<h3>Rules</h3>

<p>The validation rules are defined in the <em>spec</em> argument to <em>parambulator</em>. The rules are specified as an object, the properties of which are the rule names, and the values the rule options, like so: <code>{required$:['foo','bar']}</code>. The rules are executed in the order that they appear (JavaScript preserves the order of object properties).</p>

<p>Rule names always end with a <code>$</code> character. Properties that do not end with <code>$</code> are considered to be literal property names:</p>

<div class="highlight"><pre lang="javascript">{
  required$: ['foo','bar'],
  foo: {
    type$: 'string'
  }
}
</pre></div>

<p>This specification requires the input object to have two properties, <em>foo</em> and <em>bar</em>, and for the <em>foo</em> property to have a string value. For example, this is valid:</p>

<div class="highlight"><pre lang="javascript">{ foo:'hello', bar:1 }
</pre></div>

<p>But these are not:</p>

<div class="highlight"><pre lang="javascript">{ foo:1, bar:1 }  // foo is not a string
{ foo:'hello' }   // bar is missing
</pre></div>

<p>The rules are evaluated in the order they appear:</p>

<ol>
<li>at the current property (i.e. the top level), check for properties <em>foo</em> and <em>bar</em>, as per <code>required$: ['foo','bar']</code></li>
<li>descend into the <em>foo</em> property, and check that it's value is of <code>type$: 'string'</code> </li>
</ol>

<p>You can nest rules within other rules. They will be evaluated in the order they appear, depth first.</p>

<p>For each input property, the rules apply to the value or values within that property. This means that your rule specification mirrors the structure of the input object.</p>

<p>For example, the specification:</p>

<div class="highlight"><pre lang="javascript">{
  foo: {
    bar: { type$: 'integer' }
  }
}
</pre></div>

<p>matches</p>

<div class="highlight"><pre lang="javascript">{ foo: { bar: 1 } }
</pre></div>

<p>but does not match</p>

<div class="highlight"><pre lang="javascript">{ bar: { foo: 1 } }
</pre></div>

<p>In general, rules are permissive, in that they only apply if a given property is present. You need to use the <em>required$</em> rule to require that a property is always present in the input.</p>

<p>Each rule has a specific set of options relevant to that rule. For example, the <em>required$</em> rule takes an array of property names. The type$ rule takes a string indicating the expected type: <em>string</em>, <em>number</em>, <em>boolean</em>, etc. For full details, see the rule descriptions below.</p>

<p>Literal properties can also accept a wildcard string expression. For example:</p>

<div class="highlight"><pre lang="javascript">{ foo: "ba*" }
</pre></div>

<p>This matches:</p>

<div class="highlight"><pre lang="javascript">{ foo: "ba" }
{ foo: "bar" }
{ foo: "barx" }
</pre></div>

<p>but not</p>

<div class="highlight"><pre lang="javascript">{ foo: "b" }
</pre></div>

<h3>Wildcards</h3>

<p>Sometimes you don't know the property names in advance. To handle this case, you can also use wildcard expressions in literal properties:</p>

<div class="highlight"><pre lang="javascript">{ 'a*': { type$: 'boolean' } }
</pre></div>

<p>This matches:</p>

<div class="highlight"><pre lang="javascript">{
  a: true,
  ax: false,
  ayz: true
}
</pre></div>

<p>In particular, <code>'*'</code> on its own will match any property (at the same level). Wildcard expressions have the usual syntax: <code>*</code> means match anything, and <code>?</code> means match a single character.</p>

<p>What about repeatedly nested rules? In this situation, you want to apply the same set of rules at any depth. You can use the special literal property <code>'**'</code> to achieve this:</p>

<div class="highlight"><pre lang="javascript">{ '**': { a: {type$: 'boolean' } } }
</pre></div>

<p>This matches:</p>

<div class="highlight"><pre lang="javascript">{ a:true, x:{a:false, y:{a:true}}}
</pre></div>

<p>ensuring that any properties called <em>a</em> will be an integer. The recursive descent starts from the current level.</p>

<h3>Arrays</h3>

<p>Arrays are treated as if they were objects. The property names are simply the string values of the integer array indexes. For example:</p>

<div class="highlight"><pre lang="javascript">{ a: {'0':'first'} }
</pre></div>

<p>This matches:</p>

<div class="highlight"><pre lang="javascript">{ a:['first'] } 
</pre></div>

<p>Due to a quirk in the Chrome V8 engine, the order of integer properties is not preserved. Use the special prefix <code>__</code> as a workaround:</p>

<div class="highlight"><pre lang="javascript">{ a: {'__1':'first', '__0':'second'} }
</pre></div>

<p>This matches:</p>

<div class="highlight"><pre lang="javascript">{ a:['second','first'] } 
</pre></div>

<p>but the rules are tested in order:</p>

<ol>
<li><code>'__1':'first'</code></li>
<li><code>'__0':'second'</code></li>
</ol>

<h3>Custom Errors</h3>

<p>Each rule has an associated error message. By default these explain the reason why a rule failed, and give the property path (in standard JavaScript dot syntax: <code>foo.bar.baz</code>) of the offending value. You can customize these error messages, by providing your own string templates, or by providing a function that returns the error message text.</p>

<p>Use the <em>msgs</em> property of the <em>pref</em> argument (the second argument to <em>parambulator</em>) to define custom error messages:</p>

<div class="highlight"><pre lang="javascript">var pm = parambulator({...},{
  msgs: {
     required$: 'Property <%=property%> is required, yo!'
  }
})
</pre></div>

<p>The template syntax is provided by the <em>underscore</em> module: <a href='http://underscorejs.org/#template'>http://underscorejs.org/#template</a></p>

<p>The following properties are available:</p>

<ul>
<li><em>property</em>: the relevant property name</li>
<li><em>value</em>: the string representation of the value that failed in some way</li>
<li><em>point</em>: the actual value, which could be of any type, not just a string</li>
<li><em>rule.name</em>: the name of the rule </li>
<li><em>rule.spec</em>: the rule specification, e.g. <code>'boolean'</code> for rule <code>type$:'boolean'</code> </li>
<li><em>parentpath</em>: a string locating the value in the input (properties in dot-syntax)</li>
<li><em>json</em>: a reference to the JSON.stringify function, use like so: &lt;%=json(rule.spec)%></li>
</ul>

<p>You can also specify a custom error message using a function. This lets you customize on the specific failing conditions, such as the property name:</p>

<div class="highlight"><pre lang="javascript">var pm = parambulator({...},{
  msgs: {
     required$: function(inserts){
        if( 'voodoo' == inserts.property ) {
          return "don't dare do: "+inserts.value
        }
        else {
          return 'Property '+inserts.property+' is required, yo!'
        }
     }
  }
})
</pre></div>

<p>The <em>inserts</em> parameter is an object containing the properties as above.</p>

<h2>Rules</h2>

<p>The following rules are provided out-of-the-box. To define your own rules, see below.</p>

<p>Each rule operates at the current <em>point</em>. This is the current property location inside the input object.</p>

<p>For example, with input:</p>

<div class="highlight"><pre lang="javascript">{
  foo: {
    bar: {
      baz: 'zzz'
    }
  }
}
</pre></div>

<p>the <em>point</em> <code>foo.bar</code> is the object:</p>

<div class="highlight"><pre lang="javascript">{ baz: 'zzz'} 
</pre></div>

<h3>literal property</h3>

<p>Match an input property. You can use wildcards. Accepts a set of sub rules, or a wildcard string to match against. The property names match against property names in the current point.</p>

<div class="highlight"><pre lang="javascript">{
  a:    { ... }
  'b*': { ... }
  c:    'z*'
}
</pre></div>

<h3>atmostone$</h3>

<p>Accept at most one of a list of properties. Accepts an array of property name strings. At most one of them can be present in the current point.</p>

<div class="highlight"><pre lang="javascript">{
  atmostone$: ['foo','bar']
}
</pre></div>

<h3>exactlyone$</h3>

<p>Accept exactly one of a list of properties. Accepts an array of property name strings. Exactly one of them must be present in the current point.</p>

<div class="highlight"><pre lang="javascript">{
  exactlyone$: ['foo','bar']
}
</pre></div>

<h3>atleastone$</h3>

<p>Accept at least one of a list of properties. Accepts an array of property name strings. At least one of them must be present in the current point.</p>

<div class="highlight"><pre lang="javascript">{
  exactlyone$: ['foo','bar']
}
</pre></div>

<h3>required$</h3>

<p>Specify a set of required properties. Accepts an array of property name strings, or a single property name. Wildcards can be used. All properties must be present in the current point. Can also appear as a rule specification for literal properties.</p>

<div class="highlight"><pre lang="javascript">{ required$: ['foo','b*'] } // wildcards work too!
{ required$: 'bar' }        // for convenience
{ bar: 'required$' }        // for extra convenience
{ 'b*': 'required$' }       // and that's just nice
</pre></div>

<h3>notempty$</h3>

<p>Specify a set of properties that cannot be empty, if they are present. Unlike <em>required$</em>, these properties can be absent altogether, so use <em>required$</em> if they are also required! Accepts an array of property name strings, or a single property name. Wildcards can be used. All properties are relative to the current point. Can also appear as a rule specification for literal properties.</p>

<div class="highlight"><pre lang="javascript">{ notempty$: ['foo','b*'] } // wildcards work too!
{ notempty$: 'bar' }        // for convenience
{ bar: 'notempty$' }        // for extra convenience
{ 'b*': 'notempty$' }       // and that's just nice, again
</pre></div>

<h3>wild$</h3>

<p>Specify a wildcard pattern that the property value must match. The property value does not need to be a string. See the <a href="https://github.com/rjrodger/gex">gex</a> module documentation.</p>

<div class="highlight"><pre lang="javascript">{ foo: {wild$:'b*'} } 
</pre></div>

<h3>re$</h3>

<p>Specify a regular expression that the property value must match. The property value is converted to a string. The regular epxression is given as-is, or can be in the format /.../X, where X is a modifier such as <em>i</em>.</p>

<div class="highlight"><pre lang="javascript">{ 
  foo: {re$:'a.*'}, 
  bar: {re$:'/b/i'} 
} 
</pre></div>

<h3>type$</h3>

<p>Check that a property value is of a given JavaScript type. Does not require the property to be present (use <em>required$</em> for that). Can only be used as a subrule of a literal property.</p>

<div class="highlight"><pre lang="javascript">{ 
  a: {type$:'string'}, 
  b: {type$:'number'}, 
  c: {type$:'integer'}, // can't be decimal! 
  d: {type$:'boolean'}, 
  e: {type$:'date'}, 
  f: {type$:'array'}, 
  g: {type$:'object'}, 
} 
</pre></div>

<h3>eq$</h3>

<p>Check that a property value is an exactly equal to the given value (must also match type).</p>

<div class="highlight"><pre lang="javascript">{ 
  foo: {eq$:'bar'}, 
}
</pre></div>

<h3>enum$</h3>

<p>Check that a property value is one of an enumerated list of values (can be of any type).</p>

<div class="highlight"><pre lang="javascript">{ 
  color: {enum$:['red','green','blue']}, 
}
</pre></div>

<h3>** recursion</h3>

<p>Apply a set of subrules recursively to the current point and all it's children.</p>

<div class="highlight"><pre lang="javascript">{ 
  a: {
    '**': {
      b: { type$:'integer' }
    }, 
  }
}
</pre></div>

<h2>Custom Rules</h2>

<p>You can write your own rules if you need additional validation. The <a href="https://github.com/rjrodger/parambulator/blob/master/doc/examples/range.js">range.js</a> example shows you how.</p>

<p>Define your own rules inside the <em>rules</em> property of the <em>prefs</em> argument to <em>peramabulator</em>. Each rule is just a function, for example:</p>

<div class="highlight"><pre lang="javascript">var pm = parambulator({...},{
  rules: {
     mynewrule$: function(ctxt,cb){
       ...
     }
  }
})
</pre></div>

<p>Dont forget the <code>$</code> suffix!</p>

<p>The <em>ctxt</em> parameter provides the same interface as the <em>inserts</em> object for custom messages (as above). You can execute callback or evented code inside the rule function. Call the <em>cb</em> callback without any arguments if the rule passes. </p>

<p>If the rule fails, you can use a utility function to generate an error message:</p>

<div class="highlight"><pre lang="javascript">return ctxt.util.fail(ctxt,cb)
</pre></div>

<p>Just ensure you have a custom message with the same name as the rule!</p>

<p>The built-in rule definitions in <a href="https://github.com/rjrodger/parambulator/blob/master/lib/parambulator.js">lib/parambulator.js</a> are also a good resource.</p>

<p>Tweet me <a href="http://twitter.com/rjrodger">@rjrodger</a> if you get stuck.</p>

<p>By the way, if you have a cool new rule and you thing it should be built-in, send me a pull request! Just follow the pattern for, say, <em>wild$</em> in <a href="https://github.com/rjrodger/parambulator/blob/master/lib/parambulator.js">lib/parambulator.js</a>. You'll need entries in <em>rulemap</em>, <em>msgsmap</em>, and <em>ownparams</em>.</p>

<h3>Validation of Custom Rules</h3>

<p>When you define a custom rule, you'll want to ensure that rule specifications using it are valid. You can do this by adding validation rules to the optional <em>valid</em> property of the <em>prefs</em> argument.</p>

<p>The <a href="https://github.com/rjrodger/parambulator/blob/master/doc/examples/range.js">range.js</a> example also shows you how to do this.</p>

<p>There is a gotcha. You need to escape the rule names, so that they are treated as literal properties, and not rules. To do this, use the <code>prop$</code> pseudo-rule:</p>

<div class="highlight"><pre lang="javascript">{ prop$: {name:'foo', rules:{type$:'string'}} }
</pre></div>

<p>is equivalent to:</p>

<div class="highlight"><pre lang="javascript">{ foo: {type$:'string'} }
</pre></div>

<p>The other pseudo-rule that may come in handy is the <code>list$</code> rule. This lets you specify rules using an array. Each element is a sub array with two elements, the first is the rule name, and the second the rule specification</p>

<div class="highlight"><pre lang="javascript">{
  list$: [
    ['foo', {type$:'string'}],
    ['bar', {type$:'string'}],
  ]
}
</pre></div>

<p>Take a look at the definition of <code>ownparams</code> in <a href="https://github.com/rjrodger/parambulator/blob/master/lib/parambulator.js">lib/parambulator.js</a> to see how <em>parambulator</em> validates its own input.</p>

<h3>Acknowledgements</h3>

<p>This module depends on the excellent <a href="https://github.com/documentcloud/underscore">underscore</a> module.</p>

<p>Development is sponsored by <a href="http://nearform.com">nearForm</a></p>

<p><img src="http://www.nearform.com/img/sponsored-by-nearform.png" width="300"></p>

<p>And a funky real time chart:</p>

<p><img src="http://chartaca.com/point/adb6995d-3425-4edf-8892-a6d1a232483d/s.gif" alt="" title="" /><br /><a href="http://chartaca.com/adb6995d-3425-4edf-8892-a6d1a232483d">Chartaca Hit Chart</a> </p>
